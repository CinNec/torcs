[33mcommit dbc32ae47b3462dad6f5b40a3545cc320bf9ed6d[m
Author: student <leonbeemster@xs4all.nl>
Date:   Thu Nov 2 14:25:45 2017 +0100

    added files

[1mdiff --git a/.gitignore b/.gitignore[m
[1mnew file mode 100644[m
[1mindex 0000000..21f72d7[m
[1m--- /dev/null[m
[1m+++ b/.gitignore[m
[36m@@ -0,0 +1,4 @@[m
[32m+[m[32mtest/.cache[m
[32m+[m[32m__pycache__/[m
[32m+[m[32mdrivelogs/[m
[32m+[m[32moutput/[m
[1mdiff --git a/LICENSE b/LICENSE[m
[1mnew file mode 100644[m
[1mindex 0000000..68de721[m
[1m--- /dev/null[m
[1m+++ b/LICENSE[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32mMIT License[m
[32m+[m
[32m+[m[32mCopyright (c) 2016 Mike Pagel[m
[32m+[m
[32m+[m[32mPermission is hereby granted, free of charge, to any person obtaining a copy[m
[32m+[m[32mof this software and associated documentation files (the "Software"), to deal[m
[32m+[m[32min the Software without restriction, including without limitation the rights[m
[32m+[m[32mto use, copy, modify, merge, publish, distribute, sublicense, and/or sell[m
[32m+[m[32mcopies of the Software, and to permit persons to whom the Software is[m
[32m+[m[32mfurnished to do so, subject to the following conditions:[m
[32m+[m
[32m+[m[32mThe above copyright notice and this permission notice shall be included in all[m
[32m+[m[32mcopies or substantial portions of the Software.[m
[32m+[m
[32m+[m[32mTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR[m
[32m+[m[32mIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,[m
[32m+[m[32mFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE[m
[32m+[m[32mAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER[m
[32m+[m[32mLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,[m
[32m+[m[32mOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE[m
[32m+[m[32mSOFTWARE.[m
[1mdiff --git a/README.md b/README.md[m
[1mnew file mode 100644[m
[1mindex 0000000..a09dd52[m
[1m--- /dev/null[m
[1m+++ b/README.md[m
[36m@@ -0,0 +1,29 @@[m
[32m+[m[32m<<<<<<< HEAD[m
[32m+[m[32m# Python client for TORCS with network plugin for the 2012 SCRC[m
[32m+[m
[32m+[m[32mThis is a copy of the reimplementation in Python 3 by @moltob of the original SCRC TORCS client pySrcrcClient from @lanquarden. It is used to teach ideas of computational intelligence. The file `my_driver.py` contains a shell to start writing your own driver.[m
[32m+[m
[32m+[m[32m## `Client`[m
[32m+[m
[32m+[m[32m* top level class[m
[32m+[m[32m* handles _all_ aspects of networking (connection management, encoding)[m
[32m+[m[32m* decodes class `State` from message from server, `state = self.decode(msg)`[m
[32m+[m[32m* encodes class `Command` for message to server, `msg = self.encode(command)`[m
[32m+[m[32m* internal state connection properties only and driver instance[m
[32m+[m[32m* use `Client(driver=your_driver, <other options>)` to use your own driver[m
[32m+[m
[32m+[m[32m## `Driver`[m
[32m+[m
[32m+[m[32m* encapsulates driving logic only[m
[32m+[m[32m* main entry point: `drive(state: State) -> Command`[m
[32m+[m
[32m+[m[32m## `State`[m
[32m+[m
[32m+[m[32m* represents the incoming car state[m
[32m+[m
[32m+[m[32m## `Command`[m
[32m+[m
[32m+[m[32m* holds the outgoing driving command[m
[32m+[m[32m=======[m
[32m+[m[32m# torcs[m
[32m+[m[32m>>>>>>> 14ae771ca07577b9333a72dd9341fc4be7cf0e8e[m
[1mdiff --git a/my_driver.py b/my_driver.py[m
[1mnew file mode 100644[m
[1mindex 0000000..af41cc6[m
[1m--- /dev/null[m
[1m+++ b/my_driver.py[m
[36m@@ -0,0 +1,11 @@[m
[32m+[m[32mfrom pytocl.driver import Driver[m
[32m+[m[32mfrom pytocl.car import State, Command[m
[32m+[m
[32m+[m
[32m+[m[32mclass MyDriver(Driver):[m
[32m+[m[32m    # Override the `drive` method to create your own driver[m
[32m+[m[32m    ...[m
[32m+[m[32m    # def drive(self, carstate: State) -> Command:[m
[32m+[m[32m    #     # Interesting stuff[m
[32m+[m[32m    #     command = Command(...)[m
[32m+[m[32m    #     return command[m
[1mdiff --git a/pytocl/__init__.py b/pytocl/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..e69de29[m
[1mdiff --git a/pytocl/analysis.py b/pytocl/analysis.py[m
[1mnew file mode 100644[m
[1mindex 0000000..b6a9284[m
[1m--- /dev/null[m
[1m+++ b/pytocl/analysis.py[m
[36m@@ -0,0 +1,105 @@[m
[32m+[m[32m"""Utilities to evaluate car and driver behavior."""[m
[32m+[m[32mimport datetime[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport os[m
[32m+[m[32mimport pickle[m
[32m+[m
[32m+[m[32mimport itertools[m
[32m+[m
[32m+[m[32mimport numpy as np[m
[32m+[m
[32m+[m[32m_logger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass DataLogWriter:[m
[32m+[m[32m    """Serialization of snapshots."""[m
[32m+[m
[32m+[m[32m    def __init__(self):[m
[32m+[m[32m        dirname = 'drivelogs'[m
[32m+[m[32m        timestr = datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S')[m
[32m+[m[32m        fname = 'drivelog-{}.pickle'.format(timestr)[m
[32m+[m[32m        fpath = os.path.abspath(os.path.join(dirname, fname))[m
[32m+[m[32m        _logger.info('Logging data snapshots to {}.'.format(fpath))[m
[32m+[m
[32m+[m[32m        os.makedirs(dirname, exist_ok=True)[m
[32m+[m[32m        self.file = open(fpath, 'wb')[m
[32m+[m[32m        self.pickler = pickle.Pickler(self.file)[m
[32m+[m[32m        self.numlogged = 0[m
[32m+[m
[32m+[m[32m    def __del__(self):[m
[32m+[m[32m        """Try to save data before instance is destroyed."""[m
[32m+[m[32m        self.close()[m
[32m+[m
[32m+[m[32m    def log(self, state, command):[m
[32m+[m[32m        """Log pair of data."""[m
[32m+[m[32m        if self.logging:[m
[32m+[m[32m            self.pickler.dump((state, command))[m
[32m+[m[32m            self.numlogged += 1[m
[32m+[m[32m        else:[m
[32m+[m[32m            _logger.warning('Logger closed, cannot log data to file.')[m
[32m+[m
[32m+[m[32m    def close(self):[m
[32m+[m[32m        """End logging by closing the associated file."""[m
[32m+[m[32m        if self.logging:[m
[32m+[m[32m            self.file.close()[m
[32m+[m[32m            _logger.info('Saved {} log entries.'.format(self.numlogged))[m
[32m+[m[32m            self.file = None[m
[32m+[m[32m            self.pickler = None[m
[32m+[m[32m            self.numlogged = 0[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def logging(self):[m
[32m+[m[32m        return self.file is not None[m
[32m+[m
[32m+[m
[32m+[m[32mclass DataLogReader:[m
[32m+[m[32m    """Deserialization of logged data as ``np.array``."""[m
[32m+[m
[32m+[m[32m    def __init__(self, filepath, state_attributes=None,[m
[32m+[m[32m                 command_attributes=None):[m
[32m+[m[32m        self.filepath = filepath[m
[32m+[m[32m        self.state_attributes = state_attributes or [][m
[32m+[m[32m        self.command_attributes = command_attributes or [][m
[32m+[m
[32m+[m[32m        self._current_lap_time = 0[m
[32m+[m[32m        self._last_laps_accumulated_time = 0[m
[32m+[m[32m        self._numrows = 0[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def overall_time(self):[m
[32m+[m[32m        return self._current_lap_time + self._last_laps_accumulated_time[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def array(self):[m
[32m+[m[32m        self._current_lap_time = float('-inf')[m
[32m+[m[32m        self._last_laps_accumulated_time = 0[m
[32m+[m[32m        self._numrows = 0[m
[32m+[m
[32m+[m[32m        _logger.info('Accessing data log {}.'.format(self.filepath))[m
[32m+[m[32m        with open(self.filepath, 'rb') as logfile:[m
[32m+[m[32m            unpickler = pickle.Unpickler(logfile)[m
[32m+[m[32m            rows = self.rows(unpickler)[m
[32m+[m[32m            a = np.fromiter(itertools.chain.from_iterable(rows), float)[m
[32m+[m[32m            a.resize((self._numrows, int(a.size / self._numrows)))[m
[32m+[m
[32m+[m[32m            return a[m
[32m+[m
[32m+[m[32m    def rows(self, unpickler):[m
[32m+[m[32m        """Iterates over rows in data."""[m
[32m+[m[32m        try:[m
[32m+[m[32m            while True:[m
[32m+[m[32m                state, command = unpickler.load()[m
[32m+[m
[32m+[m[32m                # compute accumulated race time:[m
[32m+[m[32m                if self._current_lap_time > state.current_lap_time:[m
[32m+[m[32m                    self._last_laps_accumulated_time += state.last_lap_time[m
[32m+[m[32m                self._current_lap_time = state.current_lap_time[m
[32m+[m
[32m+[m[32m                row = itertools.chain((self.overall_time,),[m
[32m+[m[32m                                      state.chain(*self.state_attributes),[m
[32m+[m[32m                                      command.chain(*self.command_attributes))[m
[32m+[m[32m                self._numrows += 1[m
[32m+[m
[32m+[m[32m                yield row[m
[32m+[m[32m        except EOFError:[m
[32m+[m[32m            pass[m
[1mdiff --git a/pytocl/car.py b/pytocl/car.py[m
[1mnew file mode 100644[m
[1mindex 0000000..78e180d[m
[1m--- /dev/null[m
[1m+++ b/pytocl/car.py[m
[36m@@ -0,0 +1,163 @@[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport math[m
[32m+[m[32mfrom collections import Iterable[m
[32m+[m[32mfrom functools import partialmethod[m
[32m+[m
[32m+[m[32m_logger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m[32mDEGREE_PER_RADIANS = 180 / math.pi[m
[32m+[m[32mMPS_PER_KMH = 1000 / 3600[m
[32m+[m
[32m+[m
[32m+[m[32mclass Value:[m
[32m+[m[32m    """Base class for value objects."""[m
[32m+[m
[32m+[m[32m    def __str__(self):[m
[32m+[m[32m        return '\n'.join([m
[32m+[m[32m            '{}: {}'.format(k, v) for k, v in self.__dict__.items()[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    def chain(self, *attributes):[m
[32m+[m[32m        """Attribute iterator, unpacking iterable attributes."""[m
[32m+[m[32m        for name in attributes:[m
[32m+[m[32m            value = getattr(self, name)[m
[32m+[m[32m            if isinstance(value, Iterable):[m
[32m+[m[32m                yield from value[m
[32m+[m[32m            else:[m
[32m+[m[32m                yield value[m
[32m+[m
[32m+[m
[32m+[m[32mclass State(Value):[m
[32m+[m[32m    """State of car and environment, sent periodically by racing server.[m
[32m+[m
[32m+[m[32m    Update the state's dictionary and use properties to access the various[m
[32m+[m[32m    sensor values. Value ``None`` means the sensor value is invalid or unset.[m
[32m+[m
[32m+[m[32m    Attributes:[m
[32m+[m[32m        sensor_dict: Dictionary of sensor key value pairs in string form.[m
[32m+[m[32m        angle: Angle between car direction and track axis, [-180;180], deg.[m
[32m+[m[32m        current_lap_time: Time spent in current lap, [0;inf[, s.[m
[32m+[m[32m        damage: Damage points, 0 means no damage, [0;inf[, points.[m
[32m+[m[32m        distance_from_start:[m
[32m+[m[32m            Distance of car from start line along track center, [0;inf[, m.[m
[32m+[m[32m        distance_raced:[m
[32m+[m[32m            Distance car traveled since beginning of race, [0;inf[, m.[m
[32m+[m[32m        fuel: Current fuel level, [0;inf[, l.[m
[32m+[m[32m        gear: Current gear. -1: reverse, 0: neutral,[m
[32m+[m[32m            [1;6]: corresponding forward gear.[m
[32m+[m[32m        last_lap_time: Time it took to complete last lap, [0;inf[, s.[m
[32m+[m[32m        opponents: Distances to nearest opponents in 10 deg slices in[m
[32m+[m[32m            [-180;180] deg. [0;200], m.[m
[32m+[m[32m        race_position: Position in race with respect to other cars, [1;N].[m
[32m+[m[32m        rpm: Engine's revolutions per minute, [0;inf[.[m
[32m+[m[32m        speed_x: Speed in X (forward) direction, ]-inf;inf[, m/s.[m
[32m+[m[32m        speed_y: Speed in Y (left) direction, ]-inf;inf[, m/s.[m
[32m+[m[32m        speed_z: Speed in Z (up) direction, ]-inf;inf[, m/s.[m
[32m+[m[32m        distances_from_edge: Distances to track edge along configured driver[m
[32m+[m[32m            range finders, [0;200], m.[m
[32m+[m[32m        focused_distances_from_edge: Distances to track edge, five values in[m
[32m+[m[32m            five degree range along driver focus, [0;200], m. Can be used only[m
[32m+[m[32m            once per second and while on track, otherwise values set to -1.[m
[32m+[m[32m            See ``focused_distances_from_edge_valid``.[m
[32m+[m[32m        distance_from_center: Normalized distance from track center,[m
[32m+[m[32m            -1: right edge, 0: center, 1: left edge, [0;1].[m
[32m+[m[32m        wheel_velocities: Four wheels' velocity, [0;inf[, deg/s.[m
[32m+[m[32m        z: Distance of car center of mass to track surface, ]-inf;inf[, m.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self, sensor_dict):[m
[32m+[m[32m        """Creates decoded car state from sensor value dictionary."""[m
[32m+[m[32m        self.angle = self.float_value(sensor_dict, 'angle') * \[m
[32m+[m[32m            DEGREE_PER_RADIANS[m
[32m+[m[32m        self.current_lap_time = self.float_value(sensor_dict, 'curLapTime')[m
[32m+[m[32m        self.damage = self.int_value(sensor_dict, 'damage')[m
[32m+[m[32m        self.distance_from_start = self.float_value([m
[32m+[m[32m            sensor_dict,[m
[32m+[m[32m            'distFromStart'[m
[32m+[m[32m        )[m
[32m+[m[32m        self.distance_raced = self.float_value(sensor_dict, 'distRaced')[m
[32m+[m[32m        self.fuel = self.float_value(sensor_dict, 'fuel')[m
[32m+[m[32m        self.gear = self.int_value(sensor_dict, 'gear')[m
[32m+[m[32m        self.last_lap_time = self.float_value(sensor_dict, 'lastLapTime')[m
[32m+[m[32m        self.opponents = self.floats_value(sensor_dict, 'opponents')[m
[32m+[m[32m        self.race_position = self.int_value(sensor_dict, 'racePos')[m
[32m+[m[32m        self.rpm = self.float_value(sensor_dict, 'rpm')[m
[32m+[m[32m        self.speed_x = self.float_value(sensor_dict, 'speedX') * MPS_PER_KMH[m
[32m+[m[32m        self.speed_y = self.float_value(sensor_dict, 'speedY') * MPS_PER_KMH[m
[32m+[m[32m        self.speed_z = self.float_value(sensor_dict, 'speedZ') * MPS_PER_KMH[m
[32m+[m[32m        self.distances_from_edge = self.floats_value(sensor_dict, 'track')[m
[32m+[m[32m        self.distance_from_center = self.float_value(sensor_dict, 'trackPos')[m
[32m+[m[32m        self.wheel_velocities = tuple([m
[32m+[m[32m            v * DEGREE_PER_RADIANS for v in self.floats_value([m
[32m+[m[32m                sensor_dict,[m
[32m+[m[32m                'wheelSpinVel'[m
[32m+[m[32m            )[m
[32m+[m[32m        )[m
[32m+[m[32m        self.z = self.float_value(sensor_dict, 'z')[m
[32m+[m
[32m+[m[32m        self.focused_distances_from_edge = self.floats_value([m
[32m+[m[32m            sensor_dict,[m
[32m+[m[32m            'focus'[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def distances_from_egde_valid(self):[m
[32m+[m[32m        """Flag whether regular distances are currently valid."""[m
[32m+[m[32m        return -1 not in self.distances_from_edge[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def focused_distances_from_egde_valid(self):[m
[32m+[m[32m        """Flag whether focus distances are currently valid."""[m
[32m+[m[32m        return -1 not in self.focused_distances_from_edge[m
[32m+[m
[32m+[m[32m    @staticmethod[m
[32m+[m[32m    def converted_value(sensor_dict, key, converter):[m
[32m+[m[32m        try:[m
[32m+[m[32m            return converter(sensor_dict[key])[m
[32m+[m[32m        except (ValueError, KeyError):[m
[32m+[m[32m            _logger.warning([m
[32m+[m[32m                'Expected sensor value {!r} not found.'.format(key)[m
[32m+[m[32m            )[m
[32m+[m[32m            return None[m
[32m+[m
[32m+[m[32m    float_value = partialmethod(converted_value, converter=float)[m
[32m+[m[32m    floats_value = partialmethod([m
[32m+[m[32m        converted_value,[m
[32m+[m[32m        converter=lambda l: tuple(float(v) for v in l)[m
[32m+[m[32m    )[m
[32m+[m[32m    int_value = partialmethod(converted_value, converter=int)[m
[32m+[m
[32m+[m
[32m+[m[32mclass Command(Value):[m
[32m+[m[32m    """Command to drive car during next control cycle.[m
[32m+[m
[32m+[m[32m    Attributes:[m
[32m+[m[32m        accelerator: Accelerator, 0: no gas, 1: full gas, [0;1].[m
[32m+[m[32m        brake:  Brake pedal, [0;1].[m
[32m+[m[32m        gear: Next gear. -1: reverse, 0: neutral,[m
[32m+[m[32m            [1;6]: corresponding forward gear.[m
[32m+[m[32m        steering: Rotation of steering wheel, -1: full right, 0: straight,[m
[32m+[m[32m            1: full left, [-1;1]. Full turn results in an approximate wheel[m
[32m+[m[32m            rotation of 21 degrees.[m
[32m+[m[32m        focus: Direction of driver's focus, resulting in corresponding[m
[32m+[m[32m            ``State.focused_distances_from_edge``, [-90;90], deg.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self):[m
[32m+[m[32m        self.accelerator = 0.0[m
[32m+[m[32m        self.brake = 0.0[m
[32m+[m[32m        self.gear = 0[m
[32m+[m[32m        self.steering = 0.0[m
[32m+[m[32m        self.focus = 0.0[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def actuator_dict(self):[m
[32m+[m[32m        return dict([m
[32m+[m[32m            accel=[self.accelerator],[m
[32m+[m[32m            brake=[self.brake],[m
[32m+[m[32m            gear=[self.gear],[m
[32m+[m[32m            steer=[self.steering],[m
[32m+[m[32m            clutch=[0],  # server car does not need clutch control?[m
[32m+[m[32m            focus=[self.focus],[m
[32m+[m[32m            meta=[0]  # no support for server restart via meta=1[m
[32m+[m[32m        )[m
[1mdiff --git a/pytocl/controller.py b/pytocl/controller.py[m
[1mnew file mode 100644[m
[1mindex 0000000..8a8e177[m
[1m--- /dev/null[m
[1m+++ b/pytocl/controller.py[m
[36m@@ -0,0 +1,119 @@[m
[32m+[m[32mimport abc[m
[32m+[m
[32m+[m[32mimport math[m
[32m+[m
[32m+[m
[32m+[m[32mclass Controller(abc.ABC):[m
[32m+[m[32m    """Base class for a numeric controller."""[m
[32m+[m
[32m+[m[32m    last_value = 0.0[m
[32m+[m
[32m+[m[32m    @abc.abstractproperty[m
[32m+[m[32m    def shortname(self):[m
[32m+[m[32m        """Short name of controller type to show in logs."""[m
[32m+[m
[32m+[m[32m    @abc.abstractmethod[m
[32m+[m[32m    def control(self, deviation, timestamp) -> float:[m
[32m+[m[32m        """Compute control variable from deviation of outputs."""[m
[32m+[m
[32m+[m[32m    def reset(self):[m
[32m+[m[32m        """Resets any history that my be stored in controller state."""[m
[32m+[m
[32m+[m[32m    def __str__(self):[m
[32m+[m[32m        return '{}: {:-8.3f}'.format(self.shortname, self.last_value)[m
[32m+[m
[32m+[m
[32m+[m[32mclass ProportionalController(Controller):[m
[32m+[m[32m    """P controller.[m
[32m+[m
[32m+[m[32m    Attributes:[m
[32m+[m[32m        gain: Factor applied to deviation.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self, gain):[m
[32m+[m[32m        self.gain = gain[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def shortname(self):[m
[32m+[m[32m        return 'P'[m
[32m+[m
[32m+[m[32m    def control(self, deviation, timestamp):[m
[32m+[m[32m        value = self.gain * deviation[m
[32m+[m[32m        self.last_value = value[m
[32m+[m[32m        return value[m
[32m+[m
[32m+[m
[32m+[m[32mclass DerivativeController(Controller):[m
[32m+[m[32m    """D controller.[m
[32m+[m
[32m+[m[32m    Attributes:[m
[32m+[m[32m        gain: Factor applied to derivative of error.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self, gain):[m
[32m+[m[32m        self.gain = gain[m
[32m+[m[32m        self.last_deviation = 0[m
[32m+[m[32m        self.last_timestamp = 0[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def shortname(self):[m
[32m+[m[32m        return 'D'[m
[32m+[m
[32m+[m[32m    def control(self, deviation, timestamp):[m
[32m+[m[32m        value = self.gain * (deviation - self.last_deviation) / \[m
[32m+[m[32m            (timestamp - self.last_timestamp)[m
[32m+[m[32m        self.last_value = value[m
[32m+[m[32m        self.last_deviation = deviation[m
[32m+[m[32m        self.last_timestamp = timestamp[m
[32m+[m[32m        return value[m
[32m+[m
[32m+[m[32m    def reset(self):[m
[32m+[m[32m        self.last_deviation = 0[m
[32m+[m[32m        self.last_timestamp = 0[m
[32m+[m
[32m+[m
[32m+[m[32mclass IntegrationController(Controller):[m
[32m+[m[32m    """I controller.[m
[32m+[m
[32m+[m[32m    Attributes:[m
[32m+[m[32m        gain: Factor applied to derivative of error.[m
[32m+[m[32m        integral_limit: Optional integration limit of absolute value.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self, gain, *, integral_limit=None):[m
[32m+[m[32m        self.gain = gain[m
[32m+[m[32m        self.integral_limit = integral_limit[m
[32m+[m[32m        self.integral = 0[m
[32m+[m[32m        self.last_timestamp = 0[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def shortname(self):[m
[32m+[m[32m        return 'I'[m
[32m+[m
[32m+[m[32m    def control(self, deviation, timestamp):[m
[32m+[m[32m        self.integral += deviation * (timestamp - self.last_timestamp)[m
[32m+[m[32m        if self.integral_limit and abs(self.integral) > self.integral_limit:[m
[32m+[m[32m            self.integral = math.copysign(self.integral_limit, self.integral)[m
[32m+[m[32m        self.last_timestamp = timestamp[m
[32m+[m[32m        value = self.gain * self.integral[m
[32m+[m[32m        self.last_value = value[m
[32m+[m[32m        return value[m
[32m+[m
[32m+[m[32m    def reset(self):[m
[32m+[m[32m        self.integral = 0[m
[32m+[m[32m        self.last_timestamp = 0[m
[32m+[m
[32m+[m
[32m+[m[32mclass CompositeController(Controller):[m
[32m+[m[32m    def __init__(self, *controllers):[m
[32m+[m[32m        self.controllers = controllers[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def shortname(self):[m
[32m+[m[32m        return 'Comp'[m
[32m+[m
[32m+[m[32m    def control(self, deviation, timestamp):[m
[32m+[m[32m        return sum(c.control(deviation, timestamp) for c in self.controllers)[m
[32m+[m
[32m+[m[32m    def __str__(self):[m
[32m+[m[32m        return ', '.join(str(c) for c in self.controllers)[m
[1mdiff --git a/pytocl/driver.py b/pytocl/driver.py[m
[1mnew file mode 100644[m
[1mindex 0000000..9fe79c9[m
[1m--- /dev/null[m
[1m+++ b/pytocl/driver.py[m
[36m@@ -0,0 +1,114 @@[m
[32m+[m[32mimport logging[m
[32m+[m
[32m+[m[32mimport math[m
[32m+[m
[32m+[m[32mfrom pytocl.analysis import DataLogWriter[m
[32m+[m[32mfrom pytocl.car import State, Command, MPS_PER_KMH[m
[32m+[m[32mfrom pytocl.controller import CompositeController, ProportionalController, \[m
[32m+[m[32m    IntegrationController, DerivativeController[m
[32m+[m
[32m+[m[32m_logger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass Driver:[m
[32m+[m[32m    """[m
[32m+[m[32m    Driving logic.[m
[32m+[m
[32m+[m[32m    Implement the driving intelligence in this class by processing the current[m
[32m+[m[32m    car state as inputs creating car control commands as a response. The[m
[32m+[m[32m    ``drive`` function is called periodically every 20ms and must return a[m
[32m+[m[32m    command within 10ms wall time.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self, logdata=True):[m
[32m+[m[32m        self.steering_ctrl = CompositeController([m
[32m+[m[32m            ProportionalController(0.4),[m
[32m+[m[32m            IntegrationController(0.2, integral_limit=1.5),[m
[32m+[m[32m            DerivativeController(2)[m
[32m+[m[32m        )[m
[32m+[m[32m        self.acceleration_ctrl = CompositeController([m
[32m+[m[32m            ProportionalController(3.7),[m
[32m+[m[32m        )[m
[32m+[m[32m        self.data_logger = DataLogWriter() if logdata else None[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def range_finder_angles(self):[m
[32m+[m[32m        """Iterable of 19 fixed range finder directions [deg].[m
[32m+[m
[32m+[m[32m        The values are used once at startup of the client to set the directions[m
[32m+[m[32m        of range finders. During regular execution, a 19-valued vector of track[m
[32m+[m[32m        distances in these directions is returned in ``state.State.tracks``.[m
[32m+[m[32m        """[m
[32m+[m[32m        return -90, -75, -60, -45, -30, -20, -15, -10, -5, 0, 5, 10, 15, 20, \[m
[32m+[m[32m            30, 45, 60, 75, 90[m
[32m+[m
[32m+[m[32m    def on_shutdown(self):[m
[32m+[m[32m        """[m
[32m+[m[32m        Server requested driver shutdown.[m
[32m+[m
[32m+[m[32m        Optionally implement this event handler to clean up or write data[m
[32m+[m[32m        before the application is stopped.[m
[32m+[m[32m        """[m
[32m+[m[32m        if self.data_logger:[m
[32m+[m[32m            self.data_logger.close()[m
[32m+[m[32m            self.data_logger = None[m
[32m+[m
[32m+[m[32m    def drive(self, carstate: State) -> Command:[m
[32m+[m[32m        """[m
[32m+[m[32m        Produces driving command in response to newly received car state.[m
[32m+[m
[32m+[m[32m        This is a dummy driving routine, very dumb and not really considering a[m
[32m+[m[32m        lot of inputs. But it will get the car (if not disturbed by other[m
[32m+[m[32m        drivers) successfully driven along the race track.[m
[32m+[m[32m        """[m
[32m+[m[32m        command = Command()[m
[32m+[m[32m        self.steer(carstate, 0.0, command)[m
[32m+[m
[32m+[m[32m        # ACC_LATERAL_MAX = 6400 * 5[m
[32m+[m[32m        # v_x = min(80, math.sqrt(ACC_LATERAL_MAX / abs(command.steering)))[m
[32m+[m[32m        v_x = 80[m
[32m+[m
[32m+[m[32m        self.accelerate(carstate, v_x, command)[m
[32m+[m
[32m+[m[32m        if self.data_logger:[m
[32m+[m[32m            self.data_logger.log(carstate, command)[m
[32m+[m
[32m+[m[32m        return command[m
[32m+[m
[32m+[m[32m    def accelerate(self, carstate, target_speed, command):[m
[32m+[m[32m        # compensate engine deceleration, but invisible to controller to[m
[32m+[m[32m        # prevent braking:[m
[32m+[m[32m        speed_error = 1.0025 * target_speed * MPS_PER_KMH - carstate.speed_x[m
[32m+[m[32m        acceleration = self.acceleration_ctrl.control([m
[32m+[m[32m            speed_error,[m
[32m+[m[32m            carstate.current_lap_time[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        # stabilize use of gas and brake:[m
[32m+[m[32m        acceleration = math.pow(acceleration, 3)[m
[32m+[m
[32m+[m[32m        if acceleration > 0:[m
[32m+[m[32m            if abs(carstate.distance_from_center) >= 1:[m
[32m+[m[32m                # off track, reduced grip:[m
[32m+[m[32m                acceleration = min(0.4, acceleration)[m
[32m+[m
[32m+[m[32m            command.accelerator = min(acceleration, 1)[m
[32m+[m
[32m+[m[32m            if carstate.rpm > 8000:[m
[32m+[m[32m                command.gear = carstate.gear + 1[m
[32m+[m
[32m+[m[32m        # else:[m
[32m+[m[32m        #     command.brake = min(-acceleration, 1)[m
[32m+[m
[32m+[m[32m        if carstate.rpm < 2500:[m
[32m+[m[32m            command.gear = carstate.gear - 1[m
[32m+[m
[32m+[m[32m        if not command.gear:[m
[32m+[m[32m            command.gear = carstate.gear or 1[m
[32m+[m
[32m+[m[32m    def steer(self, carstate, target_track_pos, command):[m
[32m+[m[32m        steering_error = target_track_pos - carstate.distance_from_center[m
[32m+[m[32m        command.steering = self.steering_ctrl.control([m
[32m+[m[32m            steering_error,[m
[32m+[m[32m            carstate.current_lap_time[m
[32m+[m[32m        )[m
[1mdiff --git a/pytocl/main.py b/pytocl/main.py[m
[1mnew file mode 100644[m
[1mindex 0000000..da6d587[m
[1m--- /dev/null[m
[1m+++ b/pytocl/main.py[m
[36m@@ -0,0 +1,48 @@[m
[32m+[m[32m"""Application entry point."""[m
[32m+[m[32mimport argparse[m
[32m+[m[32mimport logging[m
[32m+[m
[32m+[m[32mfrom pytocl.protocol import Client[m
[32m+[m
[32m+[m
[32m+[m[32mdef main(driver):[m
[32m+[m[32m    """Main entry point of application."""[m
[32m+[m[32m    parser = argparse.ArgumentParser([m
[32m+[m[32m        description='Client for TORCS racing car simulation with SCRC network'[m
[32m+[m[32m                    ' server.'[m
[32m+[m[32m    )[m
[32m+[m[32m    parser.add_argument([m
[32m+[m[32m        '--hostname',[m
[32m+[m[32m        help='Racing server host name.',[m
[32m+[m[32m        default='localhost'[m
[32m+[m[32m    )[m
[32m+[m[32m    parser.add_argument([m
[32m+[m[32m        '-p',[m
[32m+[m[32m        '--port',[m
[32m+[m[32m        help='Port to connect, 3001 - 3010 for clients 1 - 10.',[m
[32m+[m[32m        type=int,[m
[32m+[m[32m        default=3001[m
[32m+[m[32m    )[m
[32m+[m[32m    parser.add_argument('-v', help='Debug log level.', action='store_true')[m
[32m+[m[32m    args = parser.parse_args()[m
[32m+[m
[32m+[m[32m    # switch log level:[m
[32m+[m[32m    if args.v:[m
[32m+[m[32m        level = logging.DEBUG[m
[32m+[m[32m    else:[m
[32m+[m[32m        level = logging.INFO[m
[32m+[m[32m    del args.v[m
[32m+[m[32m    logging.basicConfig([m
[32m+[m[32m        level=level,[m
[32m+[m[32m        format="%(asctime)s %(levelname)7s %(name)s %(message)s"[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m[32m    # start client loop:[m
[32m+[m[32m    client = Client(driver=driver, **args.__dict__)[m
[32m+[m[32m    client.run()[m
[32m+[m
[32m+[m
[32m+[m[32mif __name__ == '__main__':[m
[32m+[m[32m    from pytocl.driver import Driver[m
[32m+[m
[32m+[m[32m    main(Driver())[m
[1mdiff --git a/pytocl/protocol.py b/pytocl/protocol.py[m
[1mnew file mode 100644[m
[1mindex 0000000..af36a23[m
[1m--- /dev/null[m
[1m+++ b/pytocl/protocol.py[m
[36m@@ -0,0 +1,236 @@[m
[32m+[m[32mimport enum[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport socket[m
[32m+[m
[32m+[m[32mfrom pytocl.car import State as CarState[m
[32m+[m[32mfrom pytocl.driver import Driver[m
[32m+[m
[32m+[m[32m_logger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m[32m# special messages from server:[m
[32m+[m[32mMSG_IDENTIFIED = b'***identified***'[m
[32m+[m[32mMSG_SHUTDOWN = b'***shutdown***'[m
[32m+[m[32mMSG_RESTART = b'***restart***'[m
[32m+[m
[32m+[m[32m# timeout for socket connection in seconds and msec:[m
[32m+[m[32mTO_SOCKET_SEC = 1[m
[32m+[m[32mTO_SOCKET_MSEC = TO_SOCKET_SEC * 1000[m
[32m+[m
[32m+[m
[32m+[m[32mclass Client:[m
[32m+[m[32m    """Client for TORCS racing car simulation with SCRC network server.[m
[32m+[m
[32m+[m[32m    Attributes:[m
[32m+[m[32m        hostaddr (tuple): Tuple of hostname and port.[m
[32m+[m[32m        port (int): Port number to connect, from 3001 to 3010 for ten clients.[m
[32m+[m[32m        driver (Driver): Driving logic implementation.[m
[32m+[m[32m        serializer (Serializer): Implementation of network data encoding.[m
[32m+[m[32m        state (State): Runtime state of the client.[m
[32m+[m[32m        socket (socket): UDP socket to server.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self, hostname='localhost', port=3001, *,[m
[32m+[m[32m                 driver=None, serializer=None):[m
[32m+[m[32m        self.hostaddr = (hostname, port)[m
[32m+[m[32m        self.driver = driver or Driver()[m
[32m+[m[32m        self.serializer = serializer or Serializer()[m
[32m+[m[32m        self.state = State.STOPPED[m
[32m+[m[32m        self.socket = None[m
[32m+[m
[32m+[m[32m        _logger.debug('Initializing {}.'.format(self))[m
[32m+[m
[32m+[m[32m    def __repr__(self):[m
[32m+[m[32m        return '{s.__class__.__name__}({s.hostaddr!r}) -- {s.state.name}' \[m
[32m+[m[32m            ''.format(s=self)[m
[32m+[m
[32m+[m[32m    def run(self):[m
[32m+[m[32m        """Enters cyclic execution of the client network interface."""[m
[32m+[m
[32m+[m[32m        if self.state is State.STOPPED:[m
[32m+[m[32m            _logger.debug('Starting cyclic execution.')[m
[32m+[m
[32m+[m[32m            self.state = State.STARTING[m
[32m+[m
[32m+[m[32m            try:[m
[32m+[m[32m                _logger.info('Registering driver client with server {}.'[m
[32m+[m[32m                             .format(self.hostaddr))[m
[32m+[m[32m                self._configure_udp_socket()[m
[32m+[m[32m                self._register_driver()[m
[32m+[m[32m                self.state = State.RUNNING[m
[32m+[m[32m                _logger.info('Connection successful.')[m
[32m+[m
[32m+[m[32m            except socket.error as ex:[m
[32m+[m[32m                _logger.error('Cannot connect to server: {}'.format(ex))[m
[32m+[m[32m                self.state = State.STOPPED[m
[32m+[m
[32m+[m[32m        while self.state is State.RUNNING:[m
[32m+[m[32m            self._process_server_msg()[m
[32m+[m
[32m+[m[32m        _logger.info('Client stopped.')[m
[32m+[m[32m        self.state = State.STOPPED[m
[32m+[m
[32m+[m[32m    def stop(self):[m
[32m+[m[32m        """Exits cyclic client execution (asynchronously)."""[m
[32m+[m[32m        if self.state is State.RUNNING:[m
[32m+[m[32m            _logger.info('Disconnecting from racing server.')[m
[32m+[m[32m            self.state = State.STOPPING[m
[32m+[m[32m            self.driver.on_shutdown()[m
[32m+[m
[32m+[m[32m    def _configure_udp_socket(self):[m
[32m+[m[32m        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)[m
[32m+[m[32m        self.socket.settimeout(TO_SOCKET_SEC)[m
[32m+[m
[32m+[m[32m    def _register_driver(self):[m
[32m+[m[32m        """[m
[32m+[m[32m        Sends driver's initialization data to server and waits for acceptance[m
[32m+[m[32m        response.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        angles = self.driver.range_finder_angles[m
[32m+[m[32m        assert len(angles) == 19, \[m
[32m+[m[32m            'Inconsistent length {} of range of finder iterable.'.format([m
[32m+[m[32m                len(angles)[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        data = {'init': angles}[m
[32m+[m[32m        buffer = self.serializer.encode([m
[32m+[m[32m            data,[m
[32m+[m[32m            prefix='SCR-{}'.format(self.hostaddr[1])[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        _logger.info('Registering client.')[m
[32m+[m
[32m+[m[32m        connected = False[m
[32m+[m[32m        while not connected and self.state is not State.STOPPING:[m
[32m+[m[32m            try:[m
[32m+[m[32m                _logger.debug('Sending init buffer {!r}.'.format(buffer))[m
[32m+[m[32m                self.socket.sendto(buffer, self.hostaddr)[m
[32m+[m
[32m+[m[32m                buffer, _ = self.socket.recvfrom(TO_SOCKET_MSEC)[m
[32m+[m[32m                _logger.debug('Received buffer {!r}.'.format(buffer))[m
[32m+[m[32m                if MSG_IDENTIFIED in buffer:[m
[32m+[m[32m                    _logger.debug('Server accepted connection.')[m
[32m+[m[32m                    connected = True[m
[32m+[m
[32m+[m[32m            except socket.error as ex:[m
[32m+[m[32m                _logger.debug('No connection to server yet ({}).'.format(ex))[m
[32m+[m
[32m+[m[32m    def _process_server_msg(self):[m
[32m+[m[32m        try:[m
[32m+[m[32m            buffer, _ = self.socket.recvfrom(TO_SOCKET_MSEC)[m
[32m+[m[32m            _logger.debug('Received buffer {!r}.'.format(buffer))[m
[32m+[m
[32m+[m[32m            if not buffer:[m
[32m+[m[32m                return[m
[32m+[m
[32m+[m[32m            elif MSG_SHUTDOWN in buffer:[m
[32m+[m[32m                _logger.info('Server requested shutdown.')[m
[32m+[m[32m                self.stop()[m
[32m+[m
[32m+[m[32m            elif MSG_RESTART in buffer:[m
[32m+[m[32m                _logger.info('Server requested restart of driver.')[m
[32m+[m[32m                self.driver.on_restart()[m
[32m+[m
[32m+[m[32m            else:[m
[32m+[m[32m                sensor_dict = self.serializer.decode(buffer)[m
[32m+[m[32m                carstate = CarState(sensor_dict)[m
[32m+[m[32m                _logger.debug(carstate)[m
[32m+[m
[32m+[m[32m                command = self.driver.drive(carstate)[m
[32m+[m
[32m+[m[32m                _logger.debug(command)[m
[32m+[m[32m                buffer = self.serializer.encode(command.actuator_dict)[m
[32m+[m[32m                _logger.debug('Sending buffer {!r}.'.format(buffer))[m
[32m+[m[32m                self.socket.sendto(buffer, self.hostaddr)[m
[32m+[m
[32m+[m[32m        except socket.error as ex:[m
[32m+[m[32m            _logger.warning('Communication with server failed: {}.'.format(ex))[m
[32m+[m
[32m+[m[32m        except KeyboardInterrupt:[m
[32m+[m[32m            _logger.info('User requested shutdown.')[m
[32m+[m[32m            self.stop()[m
[32m+[m
[32m+[m
[32m+[m[32mclass State(enum.Enum):[m
[32m+[m[32m    """The runtime state of the racing client."""[m
[32m+[m
[32m+[m[32m    # not connected to a racing server[m
[32m+[m[32m    STOPPED = 1,[m
[32m+[m[32m    # entering cyclic execution[m
[32m+[m[32m    STARTING = 2,[m
[32m+[m[32m    # connected to racing server and evaluating driver logic[m
[32m+[m[32m    RUNNING = 3,[m
[32m+[m[32m    # exiting cyclic execution loop[m
[32m+[m[32m    STOPPING = 4,[m
[32m+[m
[32m+[m
[32m+[m[32mclass Serializer:[m
[32m+[m[32m    """Serializer for racing data dirctionary."""[m
[32m+[m
[32m+[m[32m    @staticmethod[m
[32m+[m[32m    def encode(data, *, prefix=None):[m
[32m+[m[32m        """Encodes data in given dictionary.[m
[32m+[m
[32m+[m[32m        Args:[m
[32m+[m[32m            data (dict): Dictionary of payload to encode. Values are arrays of[m
[32m+[m[32m                numbers.[m
[32m+[m[32m            prefix (str|None): Optional prefix string.[m
[32m+[m
[32m+[m[32m        Returns:[m
[32m+[m[32m            Bytes to be sent over the wire.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        elements = [][m
[32m+[m
[32m+[m[32m        if prefix:[m
[32m+[m[32m            elements.append(prefix)[m
[32m+[m
[32m+[m[32m        for k, v in data.items():[m
[32m+[m[32m            if v and v[0] is not None:[m
[32m+[m[32m                # string version of number array:[m
[32m+[m[32m                vstr = map(lambda i: str(i), v)[m
[32m+[m
[32m+[m[32m                elements.append('({} {})'.format(k, ' '.join(vstr)))[m
[32m+[m
[32m+[m[32m        return ''.join(elements).encode()[m
[32m+[m
[32m+[m[32m    @staticmethod[m
[32m+[m[32m    def decode(buff):[m
[32m+[m[32m        """[m
[32m+[m[32m        Decodes network representation of sensor data received from racing[m
[32m+[m[32m        server.[m
[32m+[m[32m        """[m
[32m+[m[32m        d = {}[m
[32m+[m[32m        s = buff.decode()[m
[32m+[m
[32m+[m[32m        pos = 0[m
[32m+[m[32m        while len(s) > pos:[m
[32m+[m[32m            start = s.find('(', pos)[m
[32m+[m[32m            if start < 0:[m
[32m+[m[32m                # end of list:[m
[32m+[m[32m                break[m
[32m+[m
[32m+[m[32m            end = s.find(')', start + 1)[m
[32m+[m[32m            if end < 0:[m
[32m+[m[32m                _logger.warning('Opening brace at position {} not matched in '[m
[32m+[m[32m                                'buffer {!r}.'.format(start, buff))[m
[32m+[m[32m                break[m
[32m+[m
[32m+[m[32m            items = s[start + 1:end].split(' ')[m
[32m+[m[32m            if len(items) < 2:[m
[32m+[m[32m                _logger.warning([m
[32m+[m[32m                    'Buffer {!r} not holding proper key value pair.'.format([m
[32m+[m[32m                        buff[m
[32m+[m[32m                    )[m
[32m+[m[32m                )[m
[32m+[m[32m            else:[m
[32m+[m[32m                key = items[0][m
[32m+[m[32m                if len(items) == 2:[m
[32m+[m[32m                    value = items[1][m
[32m+[m[32m                else:[m
[32m+[m[32m                    value = items[1:][m
[32m+[m[32m                d[key] = value[m
[32m+[m
[32m+[m[32m            pos = end + 1[m
[32m+[m
[32m+[m[32m        return d[m
[1mdiff --git a/requirements.txt b/requirements.txt[m
[1mnew file mode 100644[m
[1mindex 0000000..f26ef50[m
[1m--- /dev/null[m
[1m+++ b/requirements.txt[m
[36m@@ -0,0 +1,3 @@[m
[32m+[m[32m# --only-binary :all:[m
[32m+[m[32m# matplotlib[m
[32m+[m[32mnumpy[m
[1mdiff --git a/run.py b/run.py[m
[1mnew file mode 100755[m
[1mindex 0000000..80d8ceb[m
[1m--- /dev/null[m
[1m+++ b/run.py[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32m#! /usr/bin/env python3[m
[32m+[m
[32m+[m[32mfrom pytocl.main import main[m
[32m+[m[32mfrom my_driver import MyDriver[m
[32m+[m
[32m+[m[32mif __name__ == '__main__':[m
[32m+[m[32m    main(MyDriver())[m
[1mdiff --git a/start.sh b/start.sh[m
[1mnew file mode 120000[m
[1mindex 0000000..e56fbdd[m
[1m--- /dev/null[m
[1m+++ b/start.sh[m
[36m@@ -0,0 +1 @@[m
[32m+[m[32mrun.py[m
\ No newline at end of file[m
[1mdiff --git a/test/resources/drivelog-2016-08-20-17-50-03.pickle b/test/resources/drivelog-2016-08-20-17-50-03.pickle[m
[1mnew file mode 100644[m
[1mindex 0000000..b696b25[m
Binary files /dev/null and b/test/resources/drivelog-2016-08-20-17-50-03.pickle differ
[1mdiff --git a/test/test_analysis.py b/test/test_analysis.py[m
[1mnew file mode 100644[m
[1mindex 0000000..b8bd277[m
[1m--- /dev/null[m
[1m+++ b/test/test_analysis.py[m
[36m@@ -0,0 +1,41 @@[m
[32m+[m[32mimport os[m
[32m+[m
[32m+[m[32mimport numpy as np[m
[32m+[m[32mimport pytest[m
[32m+[m
[32m+[m[32mfrom pytocl.analysis import DataLogReader[m
[32m+[m
[32m+[m
[32m+[m[32m@pytest.fixture(scope='module', autouse=True)[m
[32m+[m[32mdef working_dir():[m
[32m+[m[32m    moddir = os.path.dirname(__file__)[m
[32m+[m[32m    os.chdir(os.path.join(moddir, 'resources'))[m
[32m+[m
[32m+[m
[32m+[m[32mdef test_data_log_reader_time():[m
[32m+[m[32m    reader = DataLogReader('drivelog-2016-08-20-17-50-03.pickle')[m
[32m+[m[32m    a = reader.array[m
[32m+[m
[32m+[m[32m    # only time in retrieved data:[m
[32m+[m[32m    assert a.shape == (11965, 1)[m
[32m+[m[32m    assert a[0] == -0.982[m
[32m+[m[32m    assert a[1] == -0.962[m
[32m+[m[32m    assert a[100] == 1.044[m
[32m+[m[32m    assert a[1600] == 33.046[m
[32m+[m[32m    assert a[10000] == 206.866[m
[32m+[m
[32m+[m
[32m+[m[32mdef test_data_log_reader():[m
[32m+[m[32m    reader = DataLogReader('drivelog-2016-08-20-17-50-03.pickle',[m
[32m+[m[32m                           ('angle', 'wheel_velocities', 'current_lap_time'),[m
[32m+[m[32m                           ('accelerator', 'steering'))[m
[32m+[m[32m    a = reader.array[m
[32m+[m
[32m+[m[32m    # only time in retrieved data:[m
[32m+[m[32m    assert a.shape == (11965, 9)[m
[32m+[m[32m    assert a[0, 0] == -0.982[m
[32m+[m[32m    assert a[0, 1] == 0.11095957956283035[m
[32m+[m[32m    assert all(a[0, 2:6] == np.array((0.0, 0.0, 0.0, 0.0)))[m
[32m+[m[32m    assert a[0, 6] == -0.982[m
[32m+[m[32m    assert a[0, 7] == 1[m
[32m+[m[32m    assert a[0, 8] == 0.61104317802525454[m
[1mdiff --git a/test/test_car.py b/test/test_car.py[m
[1mnew file mode 100644[m
[1mindex 0000000..f0eaee3[m
[1m--- /dev/null[m
[1m+++ b/test/test_car.py[m
[36m@@ -0,0 +1,33 @@[m
[32m+[m[32mfrom pytocl.car import State, Command[m
[32m+[m
[32m+[m
[32m+[m[32mdef test_command_array():[m
[32m+[m[32m    c = Command()[m
[32m+[m[32m    c.accelerator = 0.2[m
[32m+[m[32m    c.gear = 1[m
[32m+[m[32m    c.steering = 0.1[m
[32m+[m
[32m+[m[32m    assert tuple(c.chain('gear')) == (1.0,)[m
[32m+[m[32m    assert tuple(c.chain('accelerator', 'steering')) == (0.2, 0.1)[m
[32m+[m
[32m+[m
[32m+[m[32mdef test_state_array():[m
[32m+[m[32m    s = State({'angle': '0.008838', 'wheelSpinVel': ['67.9393', '68.8267', '71.4009', '71.7363'],[m
[32m+[m[32m               'rpm': '4509.31', 'focus': ['26.0077', '27.9798', '30.2855', '33.0162', '36.3006'],[m
[32m+[m[32m               'trackPos': '0.126012', 'fuel': '93.9356', 'speedX': '81.5135', 'speedZ': '-2.4422',[m
[32m+[m[32m               'track': ['4.3701', '4.52608', '5.02757', '6.07753', '8.25773', '11.1429', '13.451',[m
[32m+[m[32m                         '16.712', '21.5022', '30.2855', '51.8667', '185.376', '69.9077', '26.6353',[m
[32m+[m[32m                         '12.6621', '8.2019', '6.5479', '5.82979', '5.63029'], 'gear': '3',[m
[32m+[m[32m               'damage': '0', 'distRaced': '42.6238', 'z': '0.336726', 'racePos': '1',[m
[32m+[m[32m               'speedY': '0.40771', 'curLapTime': '4.052', 'lastLapTime': '0',[m
[32m+[m[32m               'distFromStart': '1015.56',[m
[32m+[m[32m               'opponents': ['123.4', '200', '200', '200', '200', '200', '200', '200', '200', '200',[m
[32m+[m[32m                             '200', '200', '200', '200', '200', '200', '200', '200', '200', '200',[m
[32m+[m[32m                             '200', '200', '200', '200', '200', '200', '200', '200', '200', '200',[m
[32m+[m[32m                             '200', '200', '200', '200', '200', '200']})[m
[32m+[m
[32m+[m[32m    assert tuple(s.chain('angle', 'wheel_velocities', 'current_lap_time')) == ([m
[32m+[m[32m        0.5063800993366215,[m
[32m+[m[32m        3892.635153073154, 3943.4794278130635, 4090.970223435639, 4110.1872278843275,[m
[32m+[m[32m        4.052[m
[32m+[m[32m    )[m
[1mdiff --git a/test/test_protocol.py b/test/test_protocol.py[m
[1mnew file mode 100644[m
[1mindex 0000000..3702980[m
[1m--- /dev/null[m
[1m+++ b/test/test_protocol.py[m
[36m@@ -0,0 +1,120 @@[m
[32m+[m[32mfrom unittest import mock[m
[32m+[m
[32m+[m[32mfrom pytocl.protocol import Serializer, Client, State[m
[32m+[m[32mfrom pytocl.driver import Driver[m
[32m+[m[32mfrom pytocl.car import State as CarState, Command[m
[32m+[m
[32m+[m
[32m+[m[32mdef test_init_encoding():[m
[32m+[m[32m    d = Driver(False)[m
[32m+[m[32m    s = Serializer()[m
[32m+[m
[32m+[m[32m    data = {'init': d.range_finder_angles}[m
[32m+[m[32m    encoded = s.encode(data, prefix='SCR')[m
[32m+[m
[32m+[m[32m    assert encoded == b'SCR(init -90 -75 -60 -45 -30 -20 -15 -10 -5 0 5 10 15 20 30 45 60 75 90)'[m
[32m+[m
[32m+[m
[32m+[m[32mdef test_decode_server_message():[m
[32m+[m[32m    buffer = b'(angle 0.008838)' \[m
[32m+[m[32m             b'(curLapTime 4.052)' \[m
[32m+[m[32m             b'(damage 0)' \[m
[32m+[m[32m             b'(distFromStart 1015.56)' \[m
[32m+[m[32m             b'(distRaced 42.6238)' \[m
[32m+[m[32m             b'(fuel 93.9356)' \[m
[32m+[m[32m             b'(gear 3)' \[m
[32m+[m[32m             b'(lastLapTime 0)' \[m
[32m+[m[32m             b'(opponents 123.4 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200' \[m
[32m+[m[32m             b' 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200)' \[m
[32m+[m[32m             b'(racePos 1)' \[m
[32m+[m[32m             b'(rpm 4509.31)' \[m
[32m+[m[32m             b'(speedX 81.5135)' \[m
[32m+[m[32m             b'(speedY 0.40771)' \[m
[32m+[m[32m             b'(speedZ -2.4422)' \[m
[32m+[m[32m             b'(track 4.3701 4.52608 5.02757 6.07753 8.25773 11.1429 13.451 16.712 21.5022' \[m
[32m+[m[32m             b' 30.2855 51.8667 185.376 69.9077 26.6353 12.6621 8.2019 6.5479 5.82979 5.63029)' \[m
[32m+[m[32m             b'(trackPos 0.126012)' \[m
[32m+[m[32m             b'(wheelSpinVel 67.9393 68.8267 71.4009 71.7363)' \[m
[32m+[m[32m             b'(z 0.336726)' \[m
[32m+[m[32m             b'(focus 26.0077 27.9798 30.2855 33.0162 36.3006)'[m
[32m+[m
[32m+[m[32m    d = Serializer().decode(buffer)[m
[32m+[m
[32m+[m[32m    assert len(d) == 19[m
[32m+[m[32m    assert d['angle'] == '0.008838'[m
[32m+[m[32m    assert d['wheelSpinVel'] == ['67.9393', '68.8267', '71.4009', '71.7363'][m
[32m+[m
[32m+[m[32m    c = CarState(d)[m
[32m+[m
[32m+[m[32m    assert c.angle == 0.5063800993366215[m
[32m+[m[32m    assert c.current_lap_time == 4.052[m
[32m+[m[32m    assert c.damage == 0[m
[32m+[m[32m    assert c.distance_from_start == 1015.56[m
[32m+[m[32m    assert c.distance_raced == 42.6238[m
[32m+[m[32m    assert c.fuel == 93.9356[m
[32m+[m[32m    assert c.gear == 3[m
[32m+[m[32m    assert c.last_lap_time == 0.0[m
[32m+[m[32m    assert c.opponents == (123.4, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200,[m
[32m+[m[32m                           200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200,[m
[32m+[m[32m                           200, 200, 200, 200, 200, 200, 200, 200)[m
[32m+[m[32m    assert c.race_position == 1[m
[32m+[m[32m    assert c.rpm == 4509.31[m
[32m+[m[32m    assert c.speed_x == 22.64263888888889[m
[32m+[m[32m    assert c.speed_y == 0.11325277777777779[m
[32m+[m[32m    assert c.speed_z == -0.6783888888888889[m
[32m+[m[32m    assert c.distances_from_edge == (4.3701, 4.52608, 5.02757, 6.07753, 8.25773, 11.1429, 13.451,[m
[32m+[m[32m                                     16.712, 21.5022, 30.2855, 51.8667, 185.376, 69.9077, 26.6353,[m
[32m+[m[32m                                     12.6621, 8.2019, 6.5479, 5.82979, 5.63029)[m
[32m+[m[32m    assert c.distance_from_center == 0.126012[m
[32m+[m[32m    assert c.wheel_velocities == (3892.635153073154, 3943.4794278130635, 4090.970223435639,[m
[32m+[m[32m                                  4110.1872278843275)[m
[32m+[m[32m    assert c.z == 0.336726[m
[32m+[m[32m    assert c.focused_distances_from_edge == (26.0077, 27.9798, 30.2855, 33.0162, 36.3006)[m
[32m+[m[32m    assert c.focused_distances_from_egde_valid[m
[32m+[m
[32m+[m[32m    # fake bad focus value:[m
[32m+[m[32m    c.focused_distances_from_edge = (-1.0, -1.0, -1.0, -1.0, -1.0)[m
[32m+[m[32m    assert not c.focused_distances_from_egde_valid[m
[32m+[m
[32m+[m
[32m+[m[32m@mock.patch('pytocl.protocol.socket.socket')[m
[32m+[m[32mdef test_special_messages(mock_socket_ctor):[m
[32m+[m[32m    mock_socket = mock.MagicMock()[m
[32m+[m[32m    mock_socket_ctor.return_value = mock_socket[m
[32m+[m[32m    mock_driver = mock.MagicMock()[m
[32m+[m[32m    mock_driver.range_finder_angles = Driver(False).range_finder_angles[m
[32m+[m[32m    client = Client(driver=mock_driver)[m
[32m+[m[32m    assert client.state is State.STOPPED[m
[32m+[m
[32m+[m[32m    mock_socket.recvfrom = mock.MagicMock(side_effect=[(b'***identified***', None),[m
[32m+[m[32m                                                       (b'***restart***', None),[m
[32m+[m[32m                                                       (b'***shutdown***', None)])[m
[32m+[m
[32m+[m[32m    client.run()[m
[32m+[m[32m    assert client.state is State.STOPPED[m
[32m+[m
[32m+[m[32m    # not supported on server side[m
[32m+[m[32m    assert mock_driver.on_restart.call_count == 1[m
[32m+[m[32m    assert mock_driver.on_shutdown.call_count == 1[m
[32m+[m
[32m+[m
[32m+[m[32mdef test_buffer_regression_1():[m
[32m+[m[32m    buffer = b'(angle 0.00585968)(curLapTime -0.982)(damage 0)(distFromStart 972.935)' \[m
[32m+[m[32m             b'(distRaced 0)(fuel 94)(gear 0)(lastLapTime 0)(opponents 200 200 200 200 ' \[m
[32m+[m[32m             b'200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 ' \[m
[32m+[m[32m             b'200 200 200 200 200 200 200 200 200 200 200 200 200 200)(racePos 1)(rpm 942.478)' \[m
[32m+[m[32m             b'(speedX 0.0206057)(speedY 0.000264679)(speedZ -0.000624058)' \[m
[32m+[m[32m             b'(track 5.00273 5.18736 5.79627 7.10971 9.87425 13.5626 16.5008 20.583 26.1558 ' \[m
[32m+[m[32m             b'33.4167 42.2603 52.3137 63.2249 17.1145 10.1787 7.03222 5.75109 5.16562 4.99744)' \[m
[32m+[m[32m             b'(trackPos -0.000529385)(wheelSpinVel 0 0 0 0)(z 0.355918)(focus -1 -1 -1 -1 -1)\x00'[m
[32m+[m
[32m+[m[32m    s = Serializer()[m
[32m+[m[32m    d = s.decode(buffer)[m
[32m+[m[32m    assert d['z'] == '0.355918'[m
[32m+[m
[32m+[m
[32m+[m[32mdef test_encode_command():[m
[32m+[m[32m    c = Command()[m
[32m+[m[32m    buffer = Serializer().encode(c.actuator_dict)[m
[32m+[m[32m    assert b'(accel 0.0)' in buffer[m
[32m+[m[32m    assert b'(clutch 0)' in buffer[m
